// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: issue.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const getIssueByID = `-- name: GetIssueByID :one
SELECT issues.id FROM "issues" WHERE issues.id = $1
`

func (q *Queries) GetIssueByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getIssueByID, id)
	err := row.Scan(&id)
	return id, err
}

const getIssueContributionByFilters = `-- name: GetIssueContributionByFilters :many
SELECT
    DATE(i.github_updated_at),
    COUNT(DISTINCT i.id) FILTER(WHERE i.status = 'OPEN') AS total_open_issues,
    COUNT(DISTINCT i.id) FILTER(WHERE i.status = 'CLOSED') AS total_closed_issues
FROM
    public.repositories r
JOIN
    public.repository_collaborators rc ON r.id = rc.repo_id
JOIN
    public.organization_collaborators oc ON rc.organization_collaborator_id = oc.id
JOIN
    public.organizations org ON oc.organization_id = org.id
LEFT JOIN
    public.issues i ON rc.id = i.repository_collaborators_id
LEFT JOIN
    public.pull_requests pr ON rc.id = pr.repository_collaborators_id
LEFT JOIN
    public.assignees a ON (i.id = a.issue_id OR pr.id = a.pr_id)
LEFT JOIN
    public.collaborators coll ON a.collaborator_id = coll.id
WHERE
    (i.github_updated_at BETWEEN $1 AND $2)   
    AND coll.id = ANY(string_to_array($3, ','))
    AND org.id = ANY(string_to_array($4, ','))
    AND r.id = ANY(string_to_array($5, ','))
GROUP BY DATE(i.github_updated_at)
`

type GetIssueContributionByFiltersParams struct {
	GithubUpdatedAt   sql.NullTime `json:"github_updated_at"`
	GithubUpdatedAt_2 sql.NullTime `json:"github_updated_at_2"`
	StringToArray     string       `json:"string_to_array"`
	StringToArray_2   string       `json:"string_to_array_2"`
	StringToArray_3   string       `json:"string_to_array_3"`
}

type GetIssueContributionByFiltersRow struct {
	Date              time.Time `json:"date"`
	TotalOpenIssues   int64     `json:"total_open_issues"`
	TotalClosedIssues int64     `json:"total_closed_issues"`
}

func (q *Queries) GetIssueContributionByFilters(ctx context.Context, arg GetIssueContributionByFiltersParams) ([]GetIssueContributionByFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getIssueContributionByFilters,
		arg.GithubUpdatedAt,
		arg.GithubUpdatedAt_2,
		arg.StringToArray,
		arg.StringToArray_2,
		arg.StringToArray_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssueContributionByFiltersRow
	for rows.Next() {
		var i GetIssueContributionByFiltersRow
		if err := rows.Scan(&i.Date, &i.TotalOpenIssues, &i.TotalClosedIssues); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssueContributionDetailsByFilters = `-- name: GetIssueContributionDetailsByFilters :many
SELECT DISTINCT
    i.id AS id,
    i.url AS url,
    i.title AS title,
    i.status AS status,
    coll.login AS assignee_name,
    r.name AS repository_name,
    org.login AS organization_name,
    i.github_updated_at AS updated_at
FROM
    public.repositories r
JOIN
    public.repository_collaborators rc ON r.id = rc.repo_id
JOIN
    public.organization_collaborators oc ON rc.organization_collaborator_id = oc.id
JOIN
    public.organizations org ON oc.organization_id = org.id
LEFT JOIN
    public.issues i ON rc.id = i.repository_collaborators_id
LEFT JOIN
    public.pull_requests pr ON rc.id = pr.repository_collaborators_id
LEFT JOIN
    public.assignees a ON (i.id = a.issue_id OR pr.id = a.pr_id)
LEFT JOIN
    public.collaborators coll ON a.collaborator_id = coll.id
WHERE
    (i.github_updated_at BETWEEN $1 AND $2)   
    AND coll.id = ANY(string_to_array($3, ','))
    AND org.id = ANY(string_to_array($4, ','))
    AND r.id = ANY(string_to_array($5, ','))
    AND i.status = ANY(string_to_array($8, ','))
ORDER BY i.github_updated_at DESC LIMIT $6 OFFSET $7
`

type GetIssueContributionDetailsByFiltersParams struct {
	GithubUpdatedAt   sql.NullTime `json:"github_updated_at"`
	GithubUpdatedAt_2 sql.NullTime `json:"github_updated_at_2"`
	StringToArray     string       `json:"string_to_array"`
	StringToArray_2   string       `json:"string_to_array_2"`
	StringToArray_3   string       `json:"string_to_array_3"`
	Limit             int32        `json:"limit"`
	Offset            int32        `json:"offset"`
	StringToArray_4   string       `json:"string_to_array_4"`
}

type GetIssueContributionDetailsByFiltersRow struct {
	ID               sql.NullString `json:"id"`
	Url              sql.NullString `json:"url"`
	Title            sql.NullString `json:"title"`
	Status           sql.NullString `json:"status"`
	AssigneeName     sql.NullString `json:"assignee_name"`
	RepositoryName   sql.NullString `json:"repository_name"`
	OrganizationName string         `json:"organization_name"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetIssueContributionDetailsByFilters(ctx context.Context, arg GetIssueContributionDetailsByFiltersParams) ([]GetIssueContributionDetailsByFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getIssueContributionDetailsByFilters,
		arg.GithubUpdatedAt,
		arg.GithubUpdatedAt_2,
		arg.StringToArray,
		arg.StringToArray_2,
		arg.StringToArray_3,
		arg.Limit,
		arg.Offset,
		arg.StringToArray_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssueContributionDetailsByFiltersRow
	for rows.Next() {
		var i GetIssueContributionDetailsByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Status,
			&i.AssigneeName,
			&i.RepositoryName,
			&i.OrganizationName,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssueCountByFilters = `-- name: GetIssueCountByFilters :one
SELECT
    COUNT(DISTINCT i.id) AS issue_count
FROM
    public.repositories r
JOIN
    public.repository_collaborators rc ON r.id = rc.repo_id
JOIN
    public.organization_collaborators oc ON rc.organization_collaborator_id = oc.id
JOIN
    public.organizations org ON oc.organization_id = org.id
LEFT JOIN
    public.issues i ON rc.id = i.repository_collaborators_id
LEFT JOIN
    public.pull_requests pr ON rc.id = pr.repository_collaborators_id
LEFT JOIN
    public.assignees a ON (i.id = a.issue_id OR pr.id = a.pr_id)
LEFT JOIN
    public.collaborators coll ON a.collaborator_id = coll.id
WHERE
    (
        (pr.github_updated_at BETWEEN $1 AND $2) OR
        (i.github_updated_at BETWEEN $1 AND $2)
    )
    AND a.collaborator_id = ANY(string_to_array($3, ','))
    AND org.id = ANY(string_to_array($4, ','))
    AND r.id = ANY(string_to_array($5, ','))
`

type GetIssueCountByFiltersParams struct {
	GithubUpdatedAt   sql.NullTime `json:"github_updated_at"`
	GithubUpdatedAt_2 sql.NullTime `json:"github_updated_at_2"`
	StringToArray     string       `json:"string_to_array"`
	StringToArray_2   string       `json:"string_to_array_2"`
	StringToArray_3   string       `json:"string_to_array_3"`
}

func (q *Queries) GetIssueCountByFilters(ctx context.Context, arg GetIssueCountByFiltersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIssueCountByFilters,
		arg.GithubUpdatedAt,
		arg.GithubUpdatedAt_2,
		arg.StringToArray,
		arg.StringToArray_2,
		arg.StringToArray_3,
	)
	var issue_count int64
	err := row.Scan(&issue_count)
	return issue_count, err
}

const getUserWiseIssueContributionByFilters = `-- name: GetUserWiseIssueContributionByFilters :many
WITH CoreData AS (
    SELECT
        COUNT(DISTINCT i.id) AS issue_count,
        DATE(i.github_updated_at) AS updated_date,
        coll.login 
    FROM
        public.repositories r
    JOIN
        public.repository_collaborators rc ON r.id = rc.repo_id
    JOIN
        public.organization_collaborators oc ON rc.organization_collaborator_id = oc.id
    JOIN
        public.organizations org ON oc.organization_id = org.id
    LEFT JOIN
        public.issues i ON rc.id = i.repository_collaborators_id
    LEFT JOIN
        public.pull_requests pr ON rc.id = pr.repository_collaborators_id
    LEFT JOIN
        public.assignees a ON (i.id = a.issue_id OR pr.id = a.pr_id)
    LEFT JOIN
        public.collaborators coll ON a.collaborator_id = coll.id
    WHERE
        (i.github_updated_at BETWEEN $1 AND $2)   
        AND coll.id = ANY(string_to_array($3, ','))
        AND org.id = ANY(string_to_array($4, ','))
        AND r.id = ANY(string_to_array($5, ','))
        AND i.status = $6
    GROUP BY updated_date, coll.login  
    ORDER BY updated_date DESC
),
DateSeries AS (
    SELECT user_date::date, login
    FROM (
        SELECT generate_series((SELECT min(updated_date) - interval '1 day' FROM CoreData), 
                               (SELECT max(updated_date) + interval '1 day' FROM CoreData), 
                               interval '1 day') AS user_date
    ) x
    CROSS JOIN (
        SELECT DISTINCT login
        FROM CoreData
        WHERE login IS NOT NULL
    ) y
)
SELECT 
    ds.user_date, 
    ds.login, 
    COALESCE(cd.issue_count, 0) AS issue_count 
FROM 
    DateSeries ds 
LEFT JOIN 
    CoreData cd ON ds.user_date = cd.updated_date AND cd.login = ds.login
`

type GetUserWiseIssueContributionByFiltersParams struct {
	GithubUpdatedAt   sql.NullTime `json:"github_updated_at"`
	GithubUpdatedAt_2 sql.NullTime `json:"github_updated_at_2"`
	StringToArray     string       `json:"string_to_array"`
	StringToArray_2   string       `json:"string_to_array_2"`
	StringToArray_3   string       `json:"string_to_array_3"`
	Status            string       `json:"status"`
}

type GetUserWiseIssueContributionByFiltersRow struct {
	UserDate   time.Time      `json:"user_date"`
	Login      sql.NullString `json:"login"`
	IssueCount int64          `json:"issue_count"`
}

func (q *Queries) GetUserWiseIssueContributionByFilters(ctx context.Context, arg GetUserWiseIssueContributionByFiltersParams) ([]GetUserWiseIssueContributionByFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWiseIssueContributionByFilters,
		arg.GithubUpdatedAt,
		arg.GithubUpdatedAt_2,
		arg.StringToArray,
		arg.StringToArray_2,
		arg.StringToArray_3,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWiseIssueContributionByFiltersRow
	for rows.Next() {
		var i GetUserWiseIssueContributionByFiltersRow
		if err := rows.Scan(&i.UserDate, &i.Login, &i.IssueCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertIssue = `-- name: InsertIssue :one
INSERT INTO
    "issues" (
        "id",
        "title",
        "status",
        "url",
        "number",
        "author_id",
        "repository_collaborators_id",
        "github_closed_at",
        "github_created_at",
        "github_updated_at"
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING issues.id
`

type InsertIssueParams struct {
	ID                        string         `json:"id"`
	Title                     string         `json:"title"`
	Status                    string         `json:"status"`
	Url                       sql.NullString `json:"url"`
	Number                    sql.NullInt32  `json:"number"`
	AuthorID                  string         `json:"author_id"`
	RepositoryCollaboratorsID string         `json:"repository_collaborators_id"`
	GithubClosedAt            sql.NullTime   `json:"github_closed_at"`
	GithubCreatedAt           sql.NullTime   `json:"github_created_at"`
	GithubUpdatedAt           sql.NullTime   `json:"github_updated_at"`
}

func (q *Queries) InsertIssue(ctx context.Context, arg InsertIssueParams) (string, error) {
	row := q.db.QueryRowContext(ctx, insertIssue,
		arg.ID,
		arg.Title,
		arg.Status,
		arg.Url,
		arg.Number,
		arg.AuthorID,
		arg.RepositoryCollaboratorsID,
		arg.GithubClosedAt,
		arg.GithubCreatedAt,
		arg.GithubUpdatedAt,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE
    issues
SET
    status = $2,
    title = $3,
    github_closed_at = $4,
    github_updated_at = $5,
    updated_at = $6
WHERE
    id = $1
`

type UpdateIssueParams struct {
	ID              string       `json:"id"`
	Status          string       `json:"status"`
	Title           string       `json:"title"`
	GithubClosedAt  sql.NullTime `json:"github_closed_at"`
	GithubUpdatedAt sql.NullTime `json:"github_updated_at"`
	UpdatedAt       time.Time    `json:"updated_at"`
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.ExecContext(ctx, updateIssue,
		arg.ID,
		arg.Status,
		arg.Title,
		arg.GithubClosedAt,
		arg.GithubUpdatedAt,
		arg.UpdatedAt,
	)
	return err
}
